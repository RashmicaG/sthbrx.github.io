<!DOCTYPE html>
<html lang="en">
<head>
        <title>Store Half Byte-Reverse Indexed - Articles by Samuel Mendoza-Jonas</title>
        <meta charset="utf-8" />
        <link href="https://sthbrx.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Store Half Byte-Reverse Indexed Full Atom Feed" />
        <link href="https://sthbrx.github.io/rss.xml" type="application/rss+xml" rel="alternate" title="Store Half Byte-Reverse Indexed RSS Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://sthbrx.github.io/">Store Half Byte-Reverse Indexed <strong>A Power Technical Blog</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
        </ul></nav><!-- /#menu -->
<section id="content">
<h2>Articles by Samuel Mendoza-Jonas</h2>

<ol id="post-list">
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2017/09/22/ncsi-nice-network-youve-got-there/" rel="bookmark" title="Permalink to NCSI - Nice Network You've Got There">NCSI - Nice Network You've Got There</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-09-22T10:08:00+10:00"> Fri 22 September 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>A neat piece of kernel code dropped into my lap recently, and as a way of
processing having to inject an entire network stack into by brain in
less-than-ideal time I thought we'd have a look at it here: NCSI!</p>
<h2>NCSI - Not the TV Show</h2>
<p>NCSI stands for Network Controller Sideband Interface, and put most simply it
is a way for a management controller (eg. a BMC like those found on our OpenPOWER
machines) to share a single physical network interface with a host machine.
Instead of two distinct network interfaces you plug in a single cable and both
the host and the BMC have network connectivity.</p>
<p>NCSI-capable network controllers achieve this by filtering network traffic as
it arrives and determining if it is host- or BMC-bound. To know how to do this
the BMC needs to tell the network controller what to look out for, and from a
Linux driver perspective this the focus of the NCSI protocol.</p>
<p><img alt="NCSI Overview" src="/images/sammj/ncsi_overview.png"></p>
<h2>Hi My Name Is 70:e2:84:14:24:a1</h2>
<p>The major components of what NCSI helps facilitate are:</p>
<ul>
<li>Network Controllers, known as 'Packages' in this context. There may be multiple
  separate packages which contain one or more Channels.</li>
<li>Channels, most easily thought of as the individual physical network interfaces.
  If a package is the network card, channels are the individual network jacks. (Somewhere a pedant's head is spinning in circles).</li>
<li>Management Controllers, or our BMC, with their own network interfaces. Hypothetically there can be multiple
  management controllers in a single NCSI system, but I've not come across such
  a setup yet.</li>
</ul>
<p>NCSI is the medium and protocol via which these components communicate.</p>
<p><img alt="NCSI Packages" src="/images/sammj/ncsi_packages.png"></p>
<p>The interface between Management Controller and one or more
Packages carries both general network traffic to/from the Management
Controller as well as NCSI traffic between the Management Controller
and the Packages &amp; Channels. Management traffic is differentiated from
regular traffic via the inclusion of a special NCSI tag inserted
in the Ethernet frame header.
These management commands are used to discover and configure the state of the
NCSI packages and channels.</p>
<p>If a BMC's network interface is configured to use NCSI, as soon as the interface
is brought up NCSI gets to work finding and configuring a usable channel.
The NCSI driver at first glance is an intimidating combination of state machines
and packet handlers, but with enough coffee it can be represented like this:</p>
<p><img alt="NCSI State Diagram" src="/images/sammj/ncsi_states.png"></p>
<p>Without getting into the nitty gritty details the overall process for configuring
a channel enough to get packets flowing is fairly straightforward:</p>
<ul>
<li>Find available packages.</li>
<li>Find each package's available channels.</li>
<li>(At least in the Linux driver) select a channel with link.</li>
<li>Put this channel into the Initial Config State.
The Initial Config State is where all the useful configuration occurs. Here we
find out what the selected channel is capable of and its current configuration,
and set it up to recognise the traffic we're interested in. The first and most
basic way of doing this is configuring the channel to filter traffic based on
our MAC address.</li>
<li>Enable the channel and let the packets flow.</li>
</ul>
<p>At this point NCSI takes a back seat to normal network traffic, transmitting
a "Get Link Status" packet at regular intervals to monitor the channel.</p>
<h2>AEN Packets</h2>
<p>Changes can occur from the package side too; the NCSI package communicates these
back to the BMC with Asynchronous Event Notification (AEN) packets. As the name
suggests these can occur at any time and the driver needs to catch and handle these.
There are different types but they essentially boil down to changes in link state,
telling the BMC the channel needs to be reconfigured, or to select a different
channel.
These are only transmitted once and no effort is made to recover lost AEN packets -
another good reason for the NCSI driver to periodically monitor the channel.</p>
<h2>Filtering</h2>
<p>Each channel can be configured to filter traffic based on MAC address,
broadcast traffic, multicast traffic, and VLAN tagging. Associated with each of
these filters is a <em>filter table</em> which can hold a finite number of entries.
In the case of the VLAN filter each channel could match against 15 different
VLAN IDs for example, but in practice the physical device will likely
support less. Indeed the popular BCM5718 controller supports only two!</p>
<p>This is where I dived into NCSI. The driver had a lot of the pieces for
configuring VLAN filters but none of it was actually hooked up in the configure
state, and didn't have a way of actually knowing which VLAN IDs were meant to be
configured on the interface. The bulk of that work appears in <a href="https://github.com/torvalds/linux/commit/21acf63013ed3d6fce3176cc34b74064052a31b4#diff-f391518f4e552724349be3589e00dfa7">this commit</a> where we take advantage of some useful network stack callbacks to get the VLAN configuration and set them during the configuration state. Getting <em>to</em> the configuration state at some arbitrary time and then managing to assign multiple IDs was the trickiest bit, and is something I'll be looking at simplifying in the future.</p>
<hr>
<p>NCSI! A neat way to give physically separate users access to a single network controller, and if it works right you won't notice it at all. I'll surely be spending more time here (fleshing out the driver's features, better error handling, and making the state machine a touch more readable to start, and I haven't even <em>mentioned</em> HWA), so watch this space!</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2016/08/17/getting-in-sync/" rel="bookmark" title="Permalink to Getting In Sync">Getting In Sync</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2016-08-17T15:23:00+10:00"> Wed 17 August 2016 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>Since at least v1.0.0 Petitboot has used device-mapper snapshots to avoid
mounting block devices directly. Primarily this is so Petitboot can mount disks
and potentially perform filesystem recovery without worrying about messing it up
and corrupting a host's boot partition - all changes happen to the snapshot in
memory without affecting the actual device.</p>
<p>This of course gets in the way if you actually <em>do</em> want to make changes to a
block device. Petitboot will allow certain bootloader scripts to make changes
to disks if configured (eg, grubenv updates), but if you manually make changes
you would need to know the special sequence of <code>dmsetup</code> commands to merge the
snapshots back to disk. This is particulary annoying if you're trying to copy
logs to a USB device!</p>
<p>Depending on how recent a version of Petitboot you're running, there are two
ways of making sure your changes persist:</p>
<h2>Before v1.2.2</h2>
<p>If you really need to save changes from within Petitboot, the most
straightforward way is to disable snapshots. Drop to the shell and enter</p>
<div class="highlight"><pre><span></span>nvram --update-config petitboot,snapshots?=false
reboot
</pre></div>


<p>Once you have rebooted you can remount the device as read-write and
modify it as normal.</p>
<h2>After v1.2.2</h2>
<p>To make this easier while keeping the benefit of snapshots, v1.2.2 introduces
a new user-event that will merge snapshots on demand. For example:</p>
<div class="highlight"><pre><span></span>mount -o remount,rw /var/petitboot/mnt/dev/sda2
cp /var/log/messages /var/petitboot/mnt/dev/sda2/
pb-event sync@sda2
</pre></div>


<p>After calling <code>pb-event sync@yourdevice</code>, Petitboot will remount the device back to
read-only and merge the current snapshot differences back to disk. You can also
run <code>pb-event sync@all</code> to sync all existing snapshots if desired.</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2016/07/05/optical-action-at-a-distance/" rel="bookmark" title="Permalink to Optical Action at a Distance">Optical Action at a Distance</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2016-07-05T15:23:00+10:00"> Tue 05 July 2016 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>Generally when someone wants to install a Linux distro they start with an ISO
file. Now we could burn that to a DVD, walk into the server room, and put it in
our machine, but that's a pain. Instead let's look at how to do this over the
network with Petitboot!</p>
<p>At the moment Petitboot won't be able to handle an ISO file unless it's
mounted in an expected place (eg. as a mounted DVD), so we need to unpack it
somewhere. Choose somewhere to host the result and unpack the ISO via whatever
method you prefer. (For example <code>bsdtar -xf /path/to/image.iso</code>).</p>
<p>You'll get a bunch of files but for our purposes we only care about a few; the
kernel, the initrd, and the bootloader configuration file. Using
the Ubuntu 16.04 ppc64el ISO as an example, these are:</p>
<div class="highlight"><pre><span></span>./install/vmlinux
./install/initrd.gz.
./boot/grub/grub.cfg
</pre></div>


<p>In grub.cfg we can see that the boot arguments are actually quite simple:</p>
<div class="highlight"><pre><span></span>set timeout=-1

menuentry &quot;Install&quot; {
    linux   /install/vmlinux tasks=standard pkgsel/language-pack-patterns= pkgsel/install-language-support=false --- quiet
    initrd  /install/initrd.gz
}

menuentry &quot;Rescue mode&quot; {
    linux   /install/vmlinux rescue/enable=true --- quiet
    initrd  /install/initrd.gz
}
</pre></div>


<p>So all we need to do is create a PXE config file that points Petitboot towards
the correct files.</p>
<p>We're going to create a PXE config file which you could serve from your DHCP
server, but that does not mean we need to use PXE - if you just want a quick
install you only need make these files accessible to Petitboot, and then we can
use the 'Retrieve config from URL' option to download the files.</p>
<p>Create a petitboot.conf file somewhere accessible that contains (for Ubuntu):</p>
<div class="highlight"><pre><span></span>label Install Ubuntu 16.04 Xenial Xerus
    kernel http://myaccesibleserver/path/to/vmlinux
    initrd http://myaccesibleserver/path/to/initrd.gz
    append tasks=standard pkgsel/language-pack-patterns= pkgsel/install-language-support=false --- quiet
</pre></div>


<p>Then in Petitboot, select 'Retrieve config from URL' and enter
<code>http://myaccesibleserver/path/to/petitboot.conf</code>. In the main menu your new
option should appear - select it and away you go!</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2016/05/13/tell-me-about-petitboot/" rel="bookmark" title="Permalink to Tell Me About Petitboot">Tell Me About Petitboot</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2016-05-13T15:23:00+10:00"> Fri 13 May 2016 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>A Google search for 'Petitboot' brings up results from a number of places, some describing its use on <a href="https://www.ibm.com/support/knowledgecenter/linuxonibm/liabp/liabppetitboot.htm">POWER servers</a>, others talking about how to use it on the <a href="http://jk.ozlabs.org/projects/petitboot/">PS3</a>, in varying levels of detail. I tend to get a lot of general questions about Petitboot and its behaviour, and have had a few requests for a broad "Welcome to Petitboot" blog, suggesting that existing docs deal with more specific topics.. or that people just aren't reading them :)</p>
<p>So today we're going to take a bit of a crash course in the what, why, and possibly how of Petitboot. I won't delve too much into technical details, and this will be focussed on Petitboot in POWER land since that's where I spend most of my time.
Here we go!</p>
<h2>What</h2>
<p>Aside from a whole lot of firmware and kernel logs flying past, the first thing you'll see when booting a POWER server<sup>In OPAL mode at least...</sup> is Petitboot's main menu:</p>
<p><img alt="Main Menu" src="/images/sammj/mainmenu.png"></p>
<p>Petitboot is the first interact-able component a user will see. The word 'BIOS' gets thrown around a lot when discussing this area, but that is wrong, and the people using that word are wrong.</p>
<p>When the OPAL firmware layer <a href="https://github.com/open-power/skiboot">Skiboot</a> has finished its own set up, it loads a certain binary (stored on the BMC) into memory and jumps into it. This could hypothetically be anything, but for any POWER server right now it is 'Skiroot'. Skiroot is a full Linux kernel and userspace, which runs Petitboot. People often say Petitboot when they mean Skiroot - technically Petitboot is the server and UI processes that happen to run within Skiroot, and Skiroot is the full kernel and rootfs package. This is more obvious when you look at the <a href="https://github.com/open-power/op-build">op-build</a> project - Petitboot is a package built as part of the kernel and rootfs created by Buildroot.</p>
<p>Petitboot is made of two major parts - the UI processes (one for each available console), and the 'discover' server. The discover server updates the UI processes, manages and scans available disks and network devices, and performs the actual booting of host operating systems. The UI, running in ncurses, displays these options, allows the user to edit boot options and system configuration, and tells the server which boot option to kexec.</p>
<h2>Why</h2>
<p>The 'why' delves into some of the major architectural differences between a POWER machine and your average x86 machine which, as always, could spread over several blog posts and/or a textbook.</p>
<p>POWER processors don't boot themselves, instead the attached Baseboard Management Controller (BMC) does a lot of low-level poking that gets the primary processor into a state where it is ready to execute instructions. PowerVM systems would then jump directly into the PHYP hypervisor - any subsequent OS, be it AIX or Linux, would then run as a 'partition' under this hypervisor.</p>
<p>What we all really want though is to run Linux directly on the hardware, which meant a new boot process would have to be thought up while still maintaining compatibility with PowerVM so systems could be booted in either mode. Thus became OPAL, and its implementation <a href="https://github.com/open-power/skiboot">Skiboot</a>. Skipping over <em>so much</em> detail, the system ends up booting into Skiboot which acts as our firmware layer. Skiboot isn't interactive and doesn't really care about things like disks, so it loads another binary into memory and executes it - Skiroot!</p>
<p>Skiroot exists as an alternative to writing a whole new bootloader just for POWER in OPAL mode, or going through the effort to port an existing bootloader to understand the specifics of POWER. Why do all that when Linux already exists and already knows how to handle disks, network interfaces, and a thousand other things? Not to mention that when Linux gains support for fancy new devices so do we, and adding new features of our own is as simple as writing your average Linux program.</p>
<p>Skiroot itself (not including Skiboot) is roughly comparable to UEFI, or at least much more so than legacy BIOS implementations. But whereas UEFI tends to be a monolithic blob of fairly platform-specific code (in practice), Skiroot is simply a small Linux environment that anyone could put together with Buildroot.</p>
<p>A much better insight into the development and motivation behind Skiroot and Petitboot is available in Jeremy's <a href="https://www.youtube.com/watch?v=oxmMJMibZQ8">LCA2013 talk</a></p>
<h2>Back to Petitboot</h2>
<p>Petitboot is the part of the 'bootloader' that <em>did</em> need to be written, because users probably wouldn't be too thrilled if they had to manually mount disks and kexec their kernels every time they booted the machine. The Petitboot server process mounts any available disk devices and scans them for available operating systems. That's not to say that it scans the entire disk, because otherwise you could be waiting for quite some time, but rather it looks in a list of common locations for bootloader configuration files. This is handy because it means the operating system doesn't need to have any knowledge of Petitboot - it just uses its usual install scripts and Petitboot reads them to know what is available.
At the same time Petitboot makes PXE requests on configured network interfaces so we can netboot, and allows these various sources to be given relative priorities for auto-boot, plus a number of other ways to specially configure booting behaviour.</p>
<p>A particularly neat feature of existing in a Linux environment is the ability to easily recover from boot problems; whereas on another system you might need to use a Live CD to fix a misconfiguration or recover a broken filesystem, in Skiroot you can just drop to the shell and fix the issue right there.</p>
<p>In summary, Petitboot/Skiroot is a small but capable Linux environment that every OPAL POWER machine boots into, gathering up all the various local and remote boot possibilities, and presenting them to you in a state-of-the-art ncurses interface. Petitboot updates all the time, and if you come across a feature that you think Petitboot is missing, patches are very welcome at <a href="mailto:petitboot@lists.ozlabs.org">petitboot@lists.ozlabs.org</a> (or hassle me on IRC)!</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2016/03/21/no-network-for-you/" rel="bookmark" title="Permalink to No Network For You">No Network For You</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2016-03-21T15:23:00+11:00"> Mon 21 March 2016 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>In POWER land <a href="https://en.wikipedia.org/wiki/Intelligent_Platform_Management_Interface">IPMI</a> is mostly known as the method to access the machine's console and start interacting with Petitboot. However it also has a plethora of other features, handily described in the 600ish page <a href="http://www.intel.com/content/www/us/en/servers/ipmi/ipmi-second-gen-interface-spec-v2-rev1-1.html">IPMI specification</a> (which you can go read yourself).</p>
<p>One especially relevant feature to Petitboot however is the 'chassis bootdev' command, which you can use to tell Petitboot to ignore any existing boot order, and only consider boot options of the type you specify (eg. 'network', 'disk', or 'setup' to not boot at all). Support for this has been in Petitboot for a while and should work on just about any machine you can get your hands on.</p>
<h2>Network Overrides</h2>
<p>Over in OpenPOWER<sup>1</sup> land however, someone took this idea and pushed it further - why not allow the network configuration to be overwritten too? This isn't in the IPMI spec, but if you cast your gaze down to page 398 where the spec lays out the entire format of the IPMI request, there is a certain field named "OEM Parameters". This is an optional amount of space set aside for whatever you like, which in this case is going to be data describing an override of the network config.</p>
<p>This allows a user to tell Petitboot over IPMI to either;</p>
<ul>
<li>Disable the network completely,</li>
<li>Set a particular interface to use DHCP, or</li>
<li>Set a particular interface to use a specific static configuration.</li>
</ul>
<p>Any of these options will cause any existing network configurations to be ignored.</p>
<h2>Building the Request</h2>
<p>Since this is an OEM-specific command, your average ipmitool package isn't going to have a nice way of making this request, such as 'chassis bootdev network'. Rather you need to do something like this:</p>
<div class="highlight"><pre><span></span>ipmitool -I lanplus -H $yourbmc -U $user -P $pass raw 0x00 0x08 0x61 0x80 0x21 0x70 0x62 0x21 0x00 0x01 0x06 0x04 0xf4 0x52 0x14 0xf3 0x01 0xdf 0x00 0x01 0x0a 0x3d 0xa1 0x42 0x10 0x0a 0x3d 0x2 0x1
</pre></div>


<p>Horrific right? In the near future the Petitboot tree will include a helper program to format this request for you, but in the meantime (and for future reference), lets lay out how to put this together:</p>
<div class="highlight"><pre><span></span>Specify the &quot;chassis bootdev&quot; command, field 96, data field 1:
    0x00 0x08 0x61 0x80

Unique value that Petitboot recognises:
    0x21 0x70 0x62 0x21

Version field (1)
    0x00 0x01 ..   ..

Size of the hardware address (6):
    ..   ..   0x06 ..

Size of the IP address (IPv4/IPv6):
    ..   ..   ..   0x04

Hardware (MAC) address:
    0xf4 0x52 0x14 0xf3
    0x01 0xdf ..   ..

&#39;Ignore flag&#39; and DHCP/Static flag (DHCP is 0)
    ..   ..   0x00 0x01

(Below fields only required if setting a static IP)

IP Address:
    0x0a 0x3d 0xa1 0x42

Subnet Mask (eg, /16):
    0x10 ..   ..   ..
Gateway IP Address:
    ..   0x0a 0x3d 0x02
    0x01
</pre></div>


<p>Clearing a network override is as simple as making a request empty aside from the header:</p>
<div class="highlight"><pre><span></span>0x00 0x08 0x61 0x80 0x21 0x70 0x62 0x21 0x00 0x01 0x00 0x00
</pre></div>


<p>You can also read back the request over IPMI with this request:</p>
<div class="highlight"><pre><span></span>0x00 0x09 0x61 0x00 0x00
</pre></div>


<p>That's it! Ideally this is something you would be scripting rather than bashing out on the keyboard - the main use case at the moment is as a way to force a machine to netboot against a known good source, rather than whatever may be available on its other interfaces.</p>
<p>[1] The reason this is only available on OpenPOWER machines at the moment is that support for the IPMI command itself depends on the BMC firmware, and non-OpenPOWER machines use an FSP which is a different platform.</p> </div><!-- /.entry-content -->
        </article></li>
</ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 2
        <a href="https://sthbrx.github.io/author/samuel-mendoza-jonas2.html">&raquo;</a>
</p>
</section><!-- /#content -->
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>