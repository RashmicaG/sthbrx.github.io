<!DOCTYPE html>
<html lang="en">
<head>
        <title>Store Half Byte-Reverse Indexed</title>
        <meta charset="utf-8" />
        <link href="https://sthbrx.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Store Half Byte-Reverse Indexed Full Atom Feed" />
        <link href="https://sthbrx.github.io/rss.xml" type="application/rss+xml" rel="alternate" title="Store Half Byte-Reverse Indexed RSS Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://sthbrx.github.io/">Store Half Byte-Reverse Indexed <strong>A Power Technical Blog</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
        </ul></nav><!-- /#menu -->
<section id="content">
<h2>Articles in the Development category</h2>

<ol id="post-list">
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2017/09/23/stupid-solutions-to-stupid-problems-hardcoding-your-ssh-key-in-the-kernel/" rel="bookmark" title="Permalink to Stupid Solutions to Stupid Problems: Hardcoding Your SSH Key in the Kernel">Stupid Solutions to Stupid Problems: Hardcoding Your SSH Key in the Kernel</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-09-23T03:00:00+10:00"> Sat 23 September 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/andrew-donnellan.html">Andrew Donnellan</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <h2>The "problem"</h2>
<p>I'm currently working on firmware and kernel support for <a href="http://opencapi.org/">OpenCAPI</a> on POWER9.</p>
<p>I've recently been allocated a machine in the lab for development purposes. We use an internal IBM tool running on a secondary machine that triggers hardware initialisation procedures, then loads a specified <a href="https://github.com/open-power/skiboot">skiboot</a> firmware image, a kernel image, and a root file system directly into RAM. This allows us to get skiboot and Linux running without requiring the usual <a href="https://github.com/open-power/hostboot">hostboot</a> initialisation and gives us a lot of options for easier tinkering, so it's super-useful for our developers working on bringup.</p>
<p>When I got access to my machine, I figured out the necessary scripts, developed a workflow, and started fixing my code... so far, so good.</p>
<p>One day, I was trying to debug something and get logs off the machine using <code>ssh</code> and <code>scp</code>, when I got frustrated with having to repeatedly type in our ultra-secret, ultra-secure root password, <code>abc123</code>. So, I ran <code>ssh-copy-id</code> to copy over my public key, and all was good.</p>
<p>Until I rebooted the machine, when strangely, my key stopped working. It took me longer than it should have to realise that this is an obvious consequence of running entirely from an initrd that's reloaded every boot...</p>
<h2>The "solution"</h2>
<p>I mentioned something about this to Jono, my housemate/partner-in-stupid-ideas, one evening a few weeks ago. We decided that clearly, the best way to solve this problem was to hardcode my SSH public key in the kernel.</p>
<p>This would definitely be the easiest and most sensible way to solve the problem, as opposed to, say, just keeping my own copy of the root filesystem image. Or asking <a href="https://twitter.com/mikeyneuling">Mikey</a>, whose desk is three metres away from mine, whether he could use his write access to add my key to the image. Or just writing a wrapper around <a href="https://linux.die.net/man/1/sshpass">sshpass</a>...</p>
<p>One Tuesday afternoon, I was feeling bored...</p>
<h2>The approach</h2>
<p>The SSH daemon looks for authorised public keys in <code>~/.ssh/authorized_keys</code>, so we need to have a read of <code>/root/.ssh/authorized_keys</code> return a specified hard-coded string.</p>
<p>I did a bit of investigation. My first thought was to put some kind of hook inside whatever filesystem driver was being used for the root. After some digging, I found out that the filesystem type <code>rootfs</code>, as seen in <code>mount</code>, is actually backed by the <code>tmpfs</code> filesystem. I took a look around the <code>tmpfs</code> code for a while, but didn't see any way to hook in a fake file without a lot of effort - the <code>tmpfs</code> code wasn't exactly designed with this in mind.</p>
<p>I thought about it some more - what would be the easiest way to create a file such that it just returns a string?</p>
<p>Then I remembered sysfs, the filesystem normally mounted at <code>/sys</code>, which is used by various kernel subsystems to expose configuration and debugging information to userspace in the form of files. The sysfs API allows you to define a file and specify callbacks to handle reads and writes to the file.</p>
<p>That got me thinking - could I create a file in <code>/sys</code>, and then use a <a href="https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount">bind mount</a> to have that file appear where I need it in <code>/root/.ssh/authorized_keys</code>? This approach seemed fairly straightforward, so I decided to give it a try.</p>
<p>First up, creating a pseudo-file. It had been a while since the last time I'd used the sysfs API...</p>
<h2>sysfs</h2>
<p>The sysfs pseudo file system was first introduced in Linux 2.6, and is generally used for exposing system and device information.</p>
<p>Per the <a href="https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt">sysfs documentation</a>, sysfs is tied in very closely with the <a href="https://www.kernel.org/doc/Documentation/kobject.txt">kobject</a> infrastructure. sysfs exposes kobjects as directories, containing "attributes" represented as files. The kobject infrastructure provides a way to define kobjects representing entities (e.g. devices) and ksets which define collections of kobjects (e.g. devices of a particular type).</p>
<p>Using kobjects you can do lots of fancy things such as sending events to userspace when devices are hotplugged - but that's all out of the scope of this post. It turns out there's some fairly straightforward wrapper functions if all you want to do is create a kobject just to have a simple directory in sysfs.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/kobject.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ssh_key_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">ssh_kobj</span><span class="p">;</span>
        <span class="n">ssh_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;ssh&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssh_kobj</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SSH: kobject creation failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">ssh_key_init</span><span class="p">);</span>
</pre></div>


<p>This creates and adds a kobject called <code>ssh</code>. And just like that, we've got a directory in <code>/sys/ssh/</code>!</p>
<p>The next thing we have to do is define a sysfs attribute for our <code>authorized_keys</code> file. sysfs provides a framework for subsystems to define their own custom types of attributes with their own metadata - but for our purposes, we'll use the generic <code>bin_attribute</code> attribute type.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/sysfs.h&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">key</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;PUBLIC KEY HERE...&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
                        <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">memory_read_from_buffer</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bin_attr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">authorized_keys_attr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;authorized_keys&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0444</span> <span class="p">},</span>
        <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">show_key</span><span class="p">,</span>
        <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>


<p>We provide a simple callback, <code>show_key()</code>, that copies the key string into the file's buffer, and we put it in a <code>bin_attribute</code> with the appropriate name, size and permissions.</p>
<p>To actually add the attribute, we put the following in <code>ssh_key_init()</code>:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">rc</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="n">ssh_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">authorized_keys_attr</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SSH: sysfs creation failed, rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Woo, we've now got <code>/sys/ssh/authorized_keys</code>! Time to move on to the bind mount.</p>
<h2>Mounting</h2>
<p>Now that we've got a directory with the key file in it, it's time to figure out the bind mount.</p>
<p>Because I had no idea how any of the file system code works, I started off by running <code>strace</code> on <code>mount --bind ~/tmp1 ~/tmp2</code> just to see how the userspace <code>mount</code> tool uses the <code>mount</code> syscall to request the bind mount.</p>
<div class="highlight"><pre><span></span><span class="n">execve</span><span class="p">(</span><span class="s">&quot;/bin/mount&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;mount&quot;</span><span class="p">,</span> <span class="s">&quot;--bind&quot;</span><span class="p">,</span> <span class="s">&quot;/home/ajd/tmp1&quot;</span><span class="p">,</span> <span class="s">&quot;/home/ajd/tmp2&quot;</span><span class="p">],</span> <span class="p">[</span><span class="cm">/* 18 vars */</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span>

<span class="p">...</span>

<span class="n">mount</span><span class="p">(</span><span class="s">&quot;/home/ajd/tmp1&quot;</span><span class="p">,</span> <span class="s">&quot;/home/ajd/tmp2&quot;</span><span class="p">,</span> <span class="mh">0x18b78bf00</span><span class="p">,</span> <span class="n">MS_MGC_VAL</span><span class="o">|</span><span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>


<p>The first and second arguments are the source and target paths respectively. The third argument, looking at the signature of the <code>mount</code> syscall, is a pointer to a string with the file system type. Because this is a bind mount, the type is irrelevant (upon further digging, it turns out that this particular pointer is to the string "none").</p>
<p>The fourth argument is where we specify the flags bitfield. <code>MS_MGC_VAL</code> is a magic value that was required before Linux 2.4 and can now be safely ignored. <code>MS_BIND</code>, as you can probably guess, signals that we want a bind mount.</p>
<p>(The final argument is used to pass file system specific data - as you can see it's ignored here.)</p>
<p>Now, how is the syscall actually handled on the kernel side? The answer is found in <a href="http://elixir.free-electrons.com/linux/latest/source/fs/namespace.c#L2969">fs/namespace.c</a>.</p>
<div class="highlight"><pre><span></span><span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">mount</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">,</span>
                <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="cm">/* ... copy parameters from userspace memory ... */</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">do_mount</span><span class="p">(</span><span class="n">kernel_dev</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">,</span> <span class="n">kernel_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>

        <span class="cm">/* ... cleanup ... */</span>
<span class="p">}</span>
</pre></div>


<p>So in order to achieve the same thing from within the kernel, we just call <code>do_mount()</code> with exactly the same parameters as the syscall uses:</p>
<div class="highlight"><pre><span></span><span class="n">rc</span> <span class="o">=</span> <span class="n">do_mount</span><span class="p">(</span><span class="s">&quot;/sys/ssh&quot;</span><span class="p">,</span> <span class="s">&quot;/root/.ssh&quot;</span><span class="p">,</span> <span class="s">&quot;sysfs&quot;</span><span class="p">,</span> <span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SSH: bind mount failed, rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>...and we're done, right? Not so fast:</p>
<div class="highlight"><pre><span></span><span class="n">SSH</span><span class="o">:</span> <span class="n">bind</span> <span class="n">mount</span> <span class="n">failed</span><span class="o">,</span> <span class="n">rc</span> <span class="o">-</span><span class="mi">2</span>
</pre></div>


<p>-2 is <code>ENOENT</code> - no such file or directory. For some reason, we can't find <code>/sys/ssh</code>... of course, that would be because even though we've created the sysfs entry, we haven't actually mounted sysfs on <code>/sys</code>.</p>
<div class="highlight"><pre><span></span><span class="n">rc</span> <span class="o">=</span> <span class="n">do_mount</span><span class="p">(</span><span class="s">&quot;sysfs&quot;</span><span class="p">,</span> <span class="s">&quot;/sys&quot;</span><span class="p">,</span> <span class="s">&quot;sysfs&quot;</span><span class="p">,</span>
              <span class="n">MS_NOSUID</span> <span class="o">|</span> <span class="n">MS_NOEXEC</span> <span class="o">|</span> <span class="n">MS_NODEV</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>


<p>At this point, my key worked!</p>
<p>Note that this requires that your root file system has an empty directory created at <code>/sys</code> to be the mount point. Additionally, in a typical Linux distribution environment (as opposed to my hardware bringup environment), your initial root file system will contain an init script that mounts your real root file system somewhere and calls <code>pivot_root()</code> to switch to the new root file system. At that point, the bind mount won't be visible from children processes using the new root - I think this could be worked around but would require some effort.</p>
<h2>Kconfig</h2>
<p>The final piece of the puzzle is building our new code into the kernel image.</p>
<p>To allow us to switch this important functionality on and off, I added a config option to <code>fs/Kconfig</code>:</p>
<div class="highlight"><pre><span></span>config SSH_KEY
        bool &quot;Andrew&#39;s dumb SSH key hack&quot;
        default y
        help
          Hardcode an SSH key for /root/.ssh/authorized_keys.

          This is a stupid idea. If unsure, say N.
</pre></div>


<p>This will show up in <code>make menuconfig</code> under the <code>File systems</code> menu.</p>
<p>And in <code>fs/Makefile</code>:</p>
<div class="highlight"><pre><span></span><span class="nv">obj-$(CONFIG_SSH_KEY)</span>           <span class="o">+=</span> ssh_key.o
</pre></div>


<p>If <code>CONFIG_SSH_KEY</code> is set to <code>y</code>, <code>obj-$(CONFIG_SSH_KEY)</code> evaluates to <code>obj-y</code> and thus <code>ssh-key.o</code> gets compiled. Conversely, <code>obj-n</code> is completely ignored by the build system.</p>
<p>I thought I was all done... then <a href="https://twitter.com/mramboar">Andrew</a> suggested I make the contents of the key configurable, and I had to oblige. Conveniently, Kconfig options can also be strings:</p>
<div class="highlight"><pre><span></span>config SSH_KEY_VALUE
        string &quot;Value for SSH key&quot;
        depends on SSH_KEY
        help
          Enter in the content for /root/.ssh/authorized_keys.
</pre></div>


<p>Including the string in the C file is as simple as:</p>
<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="n">key</span><span class="p">[]</span> <span class="o">=</span> <span class="n">CONFIG_SSH_KEY_VALUE</span><span class="p">;</span>
</pre></div>


<p>And there we have it, a nicely configurable albeit highly limited kernel SSH backdoor!</p>
<h2>Conclusion</h2>
<p>I've put the <a href="https://github.com/ajdlinux/linux/commit/052c0cb7296f7510fd482fecbe572b641c29239f">full code</a> up on GitHub for perusal. Please don't use it, I will be extremely disappointed in you if you do.</p>
<p>Thanks to Jono for giving me stupid ideas, and the rest of OzLabs for being very angry when they saw the disgusting things I was doing.</p>
<p>Comments and further stupid suggestions welcome!</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2017/09/22/ncsi-nice-network-youve-got-there/" rel="bookmark" title="Permalink to NCSI - Nice Network You've Got There">NCSI - Nice Network You've Got There</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-09-22T10:08:00+10:00"> Fri 22 September 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>A neat piece of kernel code dropped into my lap recently, and as a way of
processing having to inject an entire network stack into by brain in
less-than-ideal time I thought we'd have a look at it here: NCSI!</p>
<h2>NCSI - Not the TV Show</h2>
<p>NCSI stands for Network Controller Sideband Interface, and put most simply it
is a way for a management controller (eg. a BMC like those found on our OpenPOWER
machines) to share a single physical network interface with a host machine.
Instead of two distinct network interfaces you plug in a single cable and both
the host and the BMC have network connectivity.</p>
<p>NCSI-capable network controllers achieve this by filtering network traffic as
it arrives and determining if it is host- or BMC-bound. To know how to do this
the BMC needs to tell the network controller what to look out for, and from a
Linux driver perspective this the focus of the NCSI protocol.</p>
<p><img alt="NCSI Overview" src="/images/sammj/ncsi_overview.png"></p>
<h2>Hi My Name Is 70:e2:84:14:24:a1</h2>
<p>The major components of what NCSI helps facilitate are:</p>
<ul>
<li>Network Controllers, known as 'Packages' in this context. There may be multiple
  separate packages which contain one or more Channels.</li>
<li>Channels, most easily thought of as the individual physical network interfaces.
  If a package is the network card, channels are the individual network jacks. (Somewhere a pedant's head is spinning in circles).</li>
<li>Management Controllers, or our BMC, with their own network interfaces. Hypothetically there can be multiple
  management controllers in a single NCSI system, but I've not come across such
  a setup yet.</li>
</ul>
<p>NCSI is the medium and protocol via which these components communicate.</p>
<p><img alt="NCSI Packages" src="/images/sammj/ncsi_packages.png"></p>
<p>The interface between Management Controller and one or more
Packages carries both general network traffic to/from the Management
Controller as well as NCSI traffic between the Management Controller
and the Packages &amp; Channels. Management traffic is differentiated from
regular traffic via the inclusion of a special NCSI tag inserted
in the Ethernet frame header.
These management commands are used to discover and configure the state of the
NCSI packages and channels.</p>
<p>If a BMC's network interface is configured to use NCSI, as soon as the interface
is brought up NCSI gets to work finding and configuring a usable channel.
The NCSI driver at first glance is an intimidating combination of state machines
and packet handlers, but with enough coffee it can be represented like this:</p>
<p><img alt="NCSI State Diagram" src="/images/sammj/ncsi_states.png"></p>
<p>Without getting into the nitty gritty details the overall process for configuring
a channel enough to get packets flowing is fairly straightforward:</p>
<ul>
<li>Find available packages.</li>
<li>Find each package's available channels.</li>
<li>(At least in the Linux driver) select a channel with link.</li>
<li>Put this channel into the Initial Config State.
The Initial Config State is where all the useful configuration occurs. Here we
find out what the selected channel is capable of and its current configuration,
and set it up to recognise the traffic we're interested in. The first and most
basic way of doing this is configuring the channel to filter traffic based on
our MAC address.</li>
<li>Enable the channel and let the packets flow.</li>
</ul>
<p>At this point NCSI takes a back seat to normal network traffic, transmitting
a "Get Link Status" packet at regular intervals to monitor the channel.</p>
<h2>AEN Packets</h2>
<p>Changes can occur from the package side too; the NCSI package communicates these
back to the BMC with Asynchronous Event Notification (AEN) packets. As the name
suggests these can occur at any time and the driver needs to catch and handle these.
There are different types but they essentially boil down to changes in link state,
telling the BMC the channel needs to be reconfigured, or to select a different
channel.
These are only transmitted once and no effort is made to recover lost AEN packets -
another good reason for the NCSI driver to periodically monitor the channel.</p>
<h2>Filtering</h2>
<p>Each channel can be configured to filter traffic based on MAC address,
broadcast traffic, multicast traffic, and VLAN tagging. Associated with each of
these filters is a <em>filter table</em> which can hold a finite number of entries.
In the case of the VLAN filter each channel could match against 15 different
VLAN IDs for example, but in practice the physical device will likely
support less. Indeed the popular BCM5718 controller supports only two!</p>
<p>This is where I dived into NCSI. The driver had a lot of the pieces for
configuring VLAN filters but none of it was actually hooked up in the configure
state, and didn't have a way of actually knowing which VLAN IDs were meant to be
configured on the interface. The bulk of that work appears in <a href="https://github.com/torvalds/linux/commit/21acf63013ed3d6fce3176cc34b74064052a31b4#diff-f391518f4e552724349be3589e00dfa7">this commit</a> where we take advantage of some useful network stack callbacks to get the VLAN configuration and set them during the configuration state. Getting <em>to</em> the configuration state at some arbitrary time and then managing to assign multiple IDs was the trickiest bit, and is something I'll be looking at simplifying in the future.</p>
<hr>
<p>NCSI! A neat way to give physically separate users access to a single network controller, and if it works right you won't notice it at all. I'll surely be spending more time here (fleshing out the driver's features, better error handling, and making the state machine a touch more readable to start, and I haven't even <em>mentioned</em> HWA), so watch this space!</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2017/07/17/xdp-on-power/" rel="bookmark" title="Permalink to XDP on Power">XDP on Power</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-07-17T10:08:00+10:00"> Mon 17 July 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/daniel-axtens.html">Daniel Axtens</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>This post is a bit of a break from the standard IBM fare of this blog,
as I now work for Canonical. But I have a soft spot for Power from my
time at IBM - and Canonical officially supports 64-bit, little-endian
Power - so when I get a spare moment I try to make sure that cool,
officially-supported technologies work on Power <em>before</em> we end up
with a customer emergency! So, without further ado, this is the story
of XDP on Power.</p>
<h2>XDP</h2>
<p>eXpress Data Path (XDP) is a cool Linux technology to allow really
fast processing of network packets.</p>
<p>Normally in Linux, a packet is received by the network card, an SKB
(<a href="http://vger.kernel.org/~davem/skb.html">socket buffer</a>) is
allocated, and the packet is passed up through the networking stack.</p>
<p>This introduces an inescapable latency penalty: we have to allocate
some memory and copy stuff around. XDP allows some network cards and
drivers to process packets early - even before the allocation of the
SKB. This is much faster, and so has applications in DDOS mitigation
and other high-speed networking use-cases. The IOVisor project has
<a href="https://www.iovisor.org/technology/xdp">much more information</a> if you
want to learn more.</p>
<h2>eBPF</h2>
<p>XDP processing is done by an eBPF program. eBPF - the extended
Berkeley Packet Filter - is an in-kernel virtual machine with a
limited set of instructions. The kernel can statically validate eBPF
programs to ensure that they terminate and are memory safe. From this
it follows that the programs cannot be Turing-complete: they do not
have backward branches, so they cannot do fancy things like
loops. Nonetheless, they're surprisingly powerful for packet
processing and tracing. eBPF programs are translated into efficient
machine code using in-kernel JIT compilers on many platforms, and
interpreted on platforms that do not have a JIT. (Yes, there are
multiple JIT implementations in the kernel. I find this a terrifying
thought.)</p>
<p>Rather than requiring people to write raw eBPF programs, you can write
them in a somewhat-restricted subset of C, and use Clang's eBPF target
to translate them. This is super handy, as it gives you access to the
kernel headers - which define a number of useful data structures like
headers for various network protocols.</p>
<h2>Trying it</h2>
<p>There are a few really interesting project that are already up and
running that allow you to explore XDP without learning the innards of
both eBPF and the kernel networking stack. I explored the samples in
the <a href="https://github.com/iovisor/bcc">bcc compiler collection</a> and also
the samples from the <a href="https://github.com/netoptimizer/prototype-kernel/">netoptimizer/prototype-kernel repository</a>.</p>
<p>The easiest way to get started with these is with a virtual machine,
as recent virtio network drivers support XDP. If you are using Ubuntu,
you can use the <a href="https://help.ubuntu.com/lts/serverguide/cloud-images-and-uvtool.html">uvt-kvm
tooling</a>
to trivially set up a VM running Ubuntu Zesty on your local machine.</p>
<p>Once your VM is installed, you need to shut it down and edit the virsh XML. </p>
<p>You need 2 vCPUs (or more) and a virtio+vhost network card. You also
need to edit the 'interface' section and add the following snippet
(with thanks to the <a href="https://www.spinics.net/lists/xdp-newbies/msg00029.html">xdp-newbies
list</a>):</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">&#39;vhost&#39;</span> <span class="na">queues=</span><span class="s">&#39;4&#39;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;host</span> <span class="na">tso4=</span><span class="s">&#39;off&#39;</span> <span class="na">tso6=</span><span class="s">&#39;off&#39;</span> <span class="na">ecn=</span><span class="s">&#39;off&#39;</span> <span class="na">ufo=</span><span class="s">&#39;off&#39;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;guest</span> <span class="na">tso4=</span><span class="s">&#39;off&#39;</span> <span class="na">tso6=</span><span class="s">&#39;off&#39;</span> <span class="na">ecn=</span><span class="s">&#39;off&#39;</span> <span class="na">ufo=</span><span class="s">&#39;off&#39;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/driver&gt;</span>
</pre></div>


<p>(If you have more than 2 vCPUs, set the queues parameter to 2x the
number of vCPUs.)</p>
<p>Then, install a modern clang (we've had issues with 3.8 - I recommend
v4+), and the usual build tools.</p>
<p>I recommend testing with the prototype-kernel tools - the DDOS
prevention tool is a good demo. Then - on x86 - you just follow their
instructions. I'm not going to repeat that here.</p>
<h2>POWERful XDP</h2>
<p>What happens when you try this on Power? Regular readers of my posts
will know to expect some
<a href="https://sthbrx.github.io/blog/2017/02/13/high-power-lustre/">minor</a>
<a href="https://sthbrx.github.io/blog/2017/02/01/namd-on-nvlink/">hitches</a>.</p>
<p>XDP does not disappoint.</p>
<p>Firstly, the prototype-kernel repository <a href="https://github.com/netoptimizer/prototype-kernel/blob/master/kernel/samples/bpf/Makefile#L92">hard codes x86</a>
as the architecture for kernel headers. You need to change it for
powerpc.</p>
<p>Then, once you get the stuff compiled, and try to run it on a
current-at-time-of-writing Zesty kernel, you'll hit a massive debug
splat ending in:</p>
<div class="highlight"><pre><span></span>32: (61) r1 = *(u32 *)(r8 +12)
misaligned packet access off 0+18+12 size 4
load_bpf_file: Permission denied
</pre></div>


<p>It turns out this is because in Ubuntu's Zesty kernel,
CONFIG_HAS_EFFICIENT_UNALIGNED_ACCESS is not set on ppc64el. Because
of that, the eBPF verifier will check that all loads are aligned - and
this load (part of checking some packet header) is not, and so the
verifier rejects the program. Unaligned access is not enabled because
the Zesty kernel is being compiled for CPU_POWER7 instead of
CPU_POWER8, and we don't have efficient unaligned access on POWER7.</p>
<p>As it turns out, IBM never released any officially supported Power7 LE
systems - LE was only ever supported on Power8. So, I <a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1699627">filed a bug</a> and
<a href="https://lists.ubuntu.com/archives/kernel-team/2017-June/085074.html">sent a patch</a>
to build Zesty kernels for POWER8 instead, and that has been accepted
and will be part of the next stable update due real soon now.</p>
<p>Sure enough, if you install a kernel with that config change, you can
verify the XDP program and load it into the kernel!</p>
<p>If you have real powerpc hardware, that's enough to use XDP on Power!
Thanks to <a href="http://michael.ellerman.id.au/">Michael Ellerman</a>,
maintainer extraordinaire, for verifying this for me.</p>
<p>If - like me - you don't have ready access to Power hardware, you're
stuffed. You can't use qemu in TCG mode: to use XDP with a VM, you
need multi-queue support, which only exists in the vhost driver, which
is only available for KVM guests. Maybe IBM should release a developer
workstation. (Hint, hint!)</p>
<p>Overall, I was pleasantly surprised by how easy things were for people
with real ppc hardware - it's encouraging to see something not require
kernel changes!</p>
<p>eBPF and XDP are definitely growing technologies - as <a href="https://twitter.com/brendangregg/status/866078955530444800">Brendan Gregg notes</a>,
now is a good time to learn them! (And those on Power have no excuse
either!)</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2017/03/29/evaluating-cephfs-on-power/" rel="bookmark" title="Permalink to Evaluating CephFS on Power">Evaluating CephFS on Power</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-03-29T00:00:00+11:00"> Wed 29 March 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/alastair-dsilva.html">Alastair D'Silva</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <h2>Methodology</h2>
<p>To evaluate CephFS, we will create a ppc64le virtual machine, with sufficient
space to compile the software, as well as 3 sparse 1TB disks to create the
object store.</p>
<p>We will then build &amp; install the Ceph packages, after adding the PowerPC
optimisiations to the code. This is done, as ceph-deploy will fetch prebuilt
packages that do not have the performance patches if the packages are not
installed.</p>
<p>Finally, we will use the ceph-deploy to deploy the instance. We will ceph-deploy
via pip, to avoid file conflicts with the packages that we built.</p>
<p>For more information on what each command does, visit the following tutorial,
upon which which this is based:
<a href="http://palmerville.github.io/2016/04/30/single-node-ceph-install.html">http://palmerville.github.io/2016/04/30/single-node-ceph-install.html</a></p>
<h3>Virtual Machine Config</h3>
<p>Create a virtual machine with at least the following:
 - 16GB of memory
 - 16 CPUs
 - 64GB disk for the root filesystem
 - 3 x 1TB for the Ceph object store
 - Ubuntu 16.04 default install (only use the 64GB disk, leave the others unpartitioned)</p>
<h3>Initial config</h3>
<ul>
<li>Enable ssh</li>
</ul>
<div class="highlight"><pre><span></span>    sudo apt install openssh-server
    sudo apt update
    sudo apt upgrade
    sudo reboot
</pre></div>


<ul>
<li>Install build tools</li>
</ul>
<div class="highlight"><pre><span></span>    sudo apt install git debhelper
</pre></div>


<h3>Build Ceph</h3>
<ul>
<li>Clone the Ceph repo by following the instructions here: <a href="http://docs.ceph.com/docs/master/install/clone-source/">http://docs.ceph.com/docs/master/install/clone-source/</a></li>
</ul>
<div class="highlight"><pre><span></span>    mkdir $HOME/src
    cd $HOME/src
    git clone --recursive https://github.com/ceph/ceph.git  # This may take a while
    cd ceph
    git checkout master
    git submodule update --force --init --recursive
</pre></div>


<ul>
<li>Cherry-pick the Power performance patches:</li>
</ul>
<div class="highlight"><pre><span></span>    git remote add kestrels https://github.com/kestrels/ceph.git
    git fetch --all
    git cherry-pick 59bed55a676ebbe3ad97d8ec005c2088553e4e11
</pre></div>


<ul>
<li>Install prerequisites</li>
</ul>
<div class="highlight"><pre><span></span>    ./install-deps.sh
    sudo apt install python-requests python-flask resource-agents curl python-cherrypy python3-pip python-django python-dateutil python-djangorestframework
    sudo pip3 install ceph-deploy
</pre></div>


<ul>
<li>Build the packages as per the instructions: <a href="http://docs.ceph.com/docs/master/install/build-ceph/">http://docs.ceph.com/docs/master/install/build-ceph/</a></li>
</ul>
<div class="highlight"><pre><span></span>    cd $HOME/src/ceph
    sudo dpkg-buildpackage -J$(nproc) # This will take a couple of hours (16 cpus)
</pre></div>


<ul>
<li>Install the packages (note that python3-ceph-argparse will fail, but is safe to ignore)</li>
</ul>
<div class="highlight"><pre><span></span>    cd $HOME/src
    sudo dpkg -i *.deb
</pre></div>


<h3>Create the ceph-deploy user</h3>
<div class="highlight"><pre><span></span>    sudo adduser ceph-deploy
    echo &quot;ceph-deploy ALL = (root) NOPASSWD:ALL&quot; | sudo tee /etc/sudoers.d/ceph-deploy
    sudo chmod 0440 /etc/sudoers.d/ceph-deploy
</pre></div>


<h3>Configure the ceph-deploy user environment</h3>
<div class="highlight"><pre><span></span>    su - ceph-deploy
    ssh-keygen
    node=`hostname`
    ssh-copy-id ceph-deploy@$node
    mkdir $HOME/ceph-cluster
    cd $HOME/ceph-cluster
    ceph-deploy new $node # If this fails, remove the bogus 127.0.1.1 entry from /etc/hosts
    echo &#39;osd pool default size = 2&#39; &gt;&gt; ceph.conf
    echo &#39;osd crush chooseleaf type = 0&#39; &gt;&gt; ceph.conf
</pre></div>


<h3>Complete the Ceph deployment</h3>
<div class="highlight"><pre><span></span>    ceph-deploy install <span class="nv">$node</span>
    ceph-deploy mon create-initial
    drives=&quot;vda vdb vdc&quot;  # the 1TB drives - check that these are correct for your system
    for drive in <span class="nv">$drives</span>; do ceph-deploy disk zap <span class="nv">$node</span>:<span class="nv">$drive</span>; ceph-deploy osd prepare <span class="nv">$node</span>:<span class="nv">$drive</span>; done
    for drive in <span class="nv">$drives</span>; do ceph-deploy osd activate <span class="nv">$node</span>:/dev/<span class="cp">${</span><span class="n">drive</span><span class="cp">}</span>1; done
    ceph-deploy admin <span class="nv">$node</span>
    sudo chmod +r /etc/ceph/ceph.client.admin.keyring
    ceph -s # Check the state of the cluster
</pre></div>


<h3>Configure CephFS</h3>
<div class="highlight"><pre><span></span>    ceph-deploy mds create $node
    ceph osd pool create cephfs_data 128
    ceph osd pool create cephfs_metadata 128
    ceph fs new cephfs cephfs_metadata cephfs_data
    sudo systemctl status ceph\*.service ceph\*.target # Ensure the ceph-osd, ceph-mon &amp; ceph-mds daemons are running
    sudo mkdir /mnt/cephfs
    key=`grep key ~/ceph-cluster/ceph.client.admin.keyring | cut -d &#39; &#39; -f 3`
    sudo mount -t ceph $node:6789:/ /mnt/cephfs -o name=admin,secret=$key
</pre></div>


<h2>References</h2>
<ol>
<li><a href="http://docs.ceph.com/docs/master/install/clone-source/">http://docs.ceph.com/docs/master/install/clone-source/</a></li>
<li><a href="http://docs.ceph.com/docs/master/install/build-ceph/">http://docs.ceph.com/docs/master/install/build-ceph/</a></li>
<li><a href="http://palmerville.github.io/2016/04/30/single-node-ceph-install.html">http://palmerville.github.io/2016/04/30/single-node-ceph-install.html</a></li>
</ol> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="https://sthbrx.github.io/blog/2017/03/24/erasure-coding-for-programmers-part-2/" rel="bookmark" title="Permalink to Erasure Coding for Programmers, Part 2">Erasure Coding for Programmers, Part 2</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-03-24T10:08:00+11:00"> Fri 24 March 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="https://sthbrx.github.io/author/daniel-axtens.html">Daniel Axtens</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>We left <a href="/blog/2017/03/20/erasure-coding-for-programmers-part-1/">part 1</a> having explored GF(2^8) and RAID 6, and asking the question "what does all this have to do with Erasure Codes?"</p>
<p>Basically, the thinking goes "RAID 6 is cool, but what if, instead of two parity disks, we had an arbitrary number of parity disks?"</p>
<p>How would we do that? Well, let's introduce our new best friend: Coding Theory!</p>
<p>Say we want to transmit some data across an error-prone medium. We don't know where the errors might occur, so we add some extra information to allow us to detect and possibly correct for errors. This is a code. Codes are a largish field of engineering, but rather than show off my knowledge about systematic linear block codes, let's press on.</p>
<p>Today, our error-prone medium is an array of inexpensive disks. Now we make this really nice assumption about disks, namely that they are either perfectly reliable or completely missing. In other words, we consider that a disk will either be present or 'erased'. We come up with 'erasure codes' that are able to reconstruct data when it is known to be missing. (This is a slightly different problem to being able to verify and correct data that might or might not be subtly corrupted. Disks also have to deal with this problem, but it is <em>not</em> something erasure codes address!)</p>
<p>The particular code we use is a Reed-Solomon code. The specific details are unimportant, but there's a really good graphical outline of the broad concepts in sections 1 and 3 of <a href="http://jerasure.org/jerasure-2.0/">the Jerasure paper/manual</a>. (Don't go on to section 4.)</p>
<p>That should give you some background on how this works at a pretty basic mathematical level. Implementation is a matter of mapping that maths (matrix multiplication) onto hardware primitives, and making it go fast.</p>
<h2>Scope</h2>
<p>I'm deliberately <em>not</em> covering some pretty vast areas of what would be required to write your own erasure coding library from scratch. I'm not going to talk about how to compose the matricies, how to invert them, or anything like that. I'm not sure how that would be a helpful exercise - ISA-L and jerasure already exist and do that for you.</p>
<p>What I want to cover is an efficient implementation of the some algorithms, once you have the matricies nailed down.</p>
<p>I'm also going to assume your library already provides a generic multiplication function in GF(2^8). That's required to construct the matrices, so it's a pretty safe assumption.</p>
<h2>The beginnings of an API</h2>
<p>Let's make this a bit more concrete.</p>
<p>This will be heavily based on the <a href="https://01.org/intel%C2%AE-storage-acceleration-library-open-source-version/documentation/isa-l-open-source-api">ISA-L API</a> but you probably want to plug into ISA-L anyway, so that shouldn't be a problem.</p>
<p>What I want to do is build up from very basic algorithmic components into something useful.</p>
<p>The first thing we want to do is to be able to is Galois Field multiplication of an entire region of bytes by an arbitrary constant.</p>
<p>We basically want <code>gf_vect_mul(size_t len, &lt;something representing the constant&gt;, unsigned char * src, unsigned char * dest)</code></p>
<h3>Simple and slow approach</h3>
<p>The simplest way is to do something like this:</p>
<div class="highlight"><pre><span></span>void gf_vect_mul_simple(size_t len, unsigned char c, unsigned char * src, unsigned char * dest) {

    size_t i;
    for (i=0; i&lt;len; i++) {
        dest[i] = gf_mul(c, src[i]);
    }
}
</pre></div>


<p>That does multiplication element by element using the library's supplied <code>gf_mul</code> function, which - as the name suggests - does GF(2^8) multiplication of a scalar by a scalar.</p>
<p>This works. The problem is that it is very, painfully, slow - in the order of a few hundred megabytes per second.</p>
<h3>Going faster</h3>
<p>How can we make this faster?</p>
<p>There are a few things we can try: if you want to explore a whole range of different ways to do this, check out the <a href="http://jerasure.org/gf-complete-1.02/">gf-complete</a> project. I'm going to assume we want to skip right to the end and know what is the fastest we've found.</p>
<p>Cast your mind back to the <a href="https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf">RAID 6 paper</a> (PDF). I talked about in <a href="/blog/2017/03/20/erasure-coding-for-programmers-part-1/">part 1</a>. That had a way of doing an efficient multiplication in GF(2^8) using vector instructions.</p>
<p>To refresh your memory, we split the multiplication into two parts - low bits and high bits, looked them up separately in a lookup table, and joined them with XOR. We then discovered that on modern Power chips, we could do that in one instruction with <code>vpermxor</code>.</p>
<p>So, a very simple way to do this would be:</p>
<ul>
<li>generate the table for <code>a</code></li>
<li>for each 16-byte chunk of our input:<ul>
<li>load the input</li>
<li>do the <code>vpermxor</code> with the table</li>
<li>save it out</li>
</ul>
</li>
</ul>
<p>Generating the tables is reasonably straight-forward, in theory. Recall that the tables are <code>a</code> * {{00},{01},...,{0f}} and <code>a</code> * {{00},{10},..,{f0}} - a couple of loops in C will generate them without difficulty. ISA-L has a function to do this, as does gf-complete in split-table mode, so I won't repeat them here.</p>
<p>So, let's recast our function to take the tables as an input rather than the constant <code>a</code>. Assume we're provided the two tables concatenated into one 32-byte chunk. That would give us:</p>
<div class="highlight"><pre><span></span>void gf_vect_mul_v2(size_t len, unsigned char * table, unsigned char * src, unsigned char * dest)
</pre></div>


<p>Here's how you would do it in C:</p>
<div class="highlight"><pre><span></span>void gf_vect_mul_v2(size_t len, unsigned char * table, unsigned char * src, unsigned char * dest) {
        vector unsigned char tbl1, tbl2, in, out;
        size_t i;

        /* Assume table, src, dest are aligned and len is a multiple of 16 */

        tbl1 = vec_ld(16, table);
        tbl2 = vec_ld(0, table);
        for (i=0; i&lt;len; i+=16) {
            in = vec_ld(i, (unsigned char *)src);
            __asm__(&quot;vpermxor %0, %1, %2, %3&quot; : &quot;=v&quot;(out) : &quot;v&quot;(tbl1), &quot;v&quot;(tbl2), &quot;v&quot;(in)
            vec_st(out, i, (unsigned char *)dest);
        }
}
</pre></div>


<p>There's a few quirks to iron out - making sure the table is laid out in the vector register in the way you expect, etc, but that generally works and is quite fast - my Power 8 VM does about 17-18 GB/s with non-cache-contained data with this implementation.</p>
<p>We can go a bit faster by doing larger chunks at a time:</p>
<div class="highlight"><pre><span></span>    for (i=0; i&lt;vlen; i+=64) {
            in1 = vec_ld(i, (unsigned char *)src);
            in2 = vec_ld(i+16, (unsigned char *)src);
            in3 = vec_ld(i+32, (unsigned char *)src);
            in4 = vec_ld(i+48, (unsigned char *)src);
            __asm__(&quot;vpermxor %0, %1, %2, %3&quot; : &quot;=v&quot;(out1) : &quot;v&quot;(tbl1), &quot;v&quot;(tbl2), &quot;v&quot;(in1));
            __asm__(&quot;vpermxor %0, %1, %2, %3&quot; : &quot;=v&quot;(out2) : &quot;v&quot;(tbl1), &quot;v&quot;(tbl2), &quot;v&quot;(in2));
            __asm__(&quot;vpermxor %0, %1, %2, %3&quot; : &quot;=v&quot;(out3) : &quot;v&quot;(tbl1), &quot;v&quot;(tbl2), &quot;v&quot;(in3));
            __asm__(&quot;vpermxor %0, %1, %2, %3&quot; : &quot;=v&quot;(out4) : &quot;v&quot;(tbl1), &quot;v&quot;(tbl2), &quot;v&quot;(in4));
            vec_st(out1, i, (unsigned char *)dest);
            vec_st(out2, i+16, (unsigned char *)dest);
            vec_st(out3, i+32, (unsigned char *)dest);
            vec_st(out4, i+48, (unsigned char *)dest);
    }
</pre></div>


<p>This goes at about 23.5 GB/s.</p>
<p>We can go one step further and do the core loop in assembler - that means we control the instruction layout and so on. I tried this: it turns out that for the basic vector multiply loop, if we turn off ASLR and pin to a particular CPU, we can see a improvement of a few percent (and a decrease in variability) over C code.</p>
<h2>Building from vector multiplication</h2>
<p>Once you're comfortable with the core vector multiplication, you can start to build more interesting routines.</p>
<p>A particularly useful one on Power turned out to be the multiply and add routine: like gf_vect_mul, except that rather than overwriting the output, it loads the output and xors the product in. This is a simple extension of the gf_vect_mul function so is left as an exercise to the reader.</p>
<p>The next step would be to start building erasure coding proper. Recall that to get an element of our output, we take a dot product: we take the corresponding input element of each disk, multiply it with the corresponding GF(2^8) coding matrix element and sum all those products. So all we need now is a dot product algorithm.</p>
<p>One approach is the conventional dot product:</p>
<ul>
<li>for each element<ul>
<li>zero accumulator</li>
<li>for each source<ul>
<li>load <code>input[source][element]</code></li>
<li>do GF(2^8) multiplication</li>
<li>xor into accumulator</li>
</ul>
</li>
<li>save accumulator to <code>output[element]</code></li>
</ul>
</li>
</ul>
<p>The other approach is multiply and add:</p>
<ul>
<li>for each source<ul>
<li>for each element<ul>
<li>load <code>input[source][element]</code></li>
<li>do GF(2^8) multiplication</li>
<li>load <code>output[element]</code></li>
<li>xor in product</li>
<li>save <code>output[element]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The dot product approach has the advantage of fewer writes. The multiply and add approach has the advantage of better cache/prefetch performance. The approach you ultimately go with will probably depend on the characteristics of your machine and the length of data you are dealing with.</p>
<p>For what it's worth, ISA-L ships with only the first approach in x86 assembler, and Jerasure leans heavily towards the second approach.</p>
<p>Once you have a vector dot product sorted, you can build a full erasure coding setup: build your tables with your library, then do a dot product to generate each of your outputs!</p>
<p>In ISA-L, this is implemented something like this:</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * ec_encode_data_simple(length of each data input, number of inputs,</span>
<span class="cm"> *                       number of outputs, pre-generated GF(2^8) tables,</span>
<span class="cm"> *                       input data pointers, output code pointers)</span>
<span class="cm"> */</span><span class="w"></span>
void<span class="w"> </span>ec_encode_data_simple<span class="o">(</span>int<span class="w"> </span>len<span class="o">,</span><span class="w"> </span>int<span class="w"> </span>k<span class="o">,</span><span class="w"> </span>int<span class="w"> </span>rows<span class="o">,</span><span class="w"> </span>unsigned<span class="w"> </span>char<span class="w"> </span><span class="o">*</span>g_tbls<span class="o">,</span><span class="w"></span>
<span class="w">                           </span>unsigned<span class="w"> </span>char<span class="w"> </span><span class="o">**</span>data<span class="o">,</span><span class="w"> </span>unsigned<span class="w"> </span>char<span class="w"> </span><span class="o">**</span>coding<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">        </span><span class="kr">while</span><span class="w"> </span><span class="o">(</span>rows<span class="o">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">                </span>gf_vect_dot_prod<span class="o">(</span>len<span class="o">,</span><span class="w"> </span>k<span class="o">,</span><span class="w"> </span>g_tbls<span class="o">,</span><span class="w"> </span>data<span class="o">,</span><span class="w"> </span><span class="o">*</span>coding<span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="w">                </span>g_tbls<span class="w"> </span><span class="o">+=</span><span class="w"> </span>k<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">32</span><span class="err">;</span><span class="w"></span>
<span class="w">                </span>coding<span class="o">++</span><span class="err">;</span><span class="w"></span>
<span class="w">                </span>rows<span class="o">--</span><span class="err">;</span><span class="w"></span>
<span class="w">        </span><span class="err">}</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<h2>Going faster still</h2>
<p>Eagle eyed readers will notice that however we generate an output, we have to read all the input elements. This means that if we're doing a code with 10 data disks and 4 coding disks, we have to read each of the 10 inputs 4 times.</p>
<p>We could do better if we could calculate multiple outputs for each pass through the inputs. This is a little fiddly to implement, but does lead to a speed improvement.</p>
<p>ISA-L is an excellent example here. Intel goes up to 6 outputs at once: the number of outputs you can do is only limited by how many vector registers you have to put the various operands and results in.</p>
<h2>Tips and tricks</h2>
<ul>
<li>
<p>Benchmarking is tricky. I do the following on a bare-metal, idle machine, with ASLR off and pinned to an arbitrary hardware thread. (Code is for the <a href="https://fishshell.com/">fish shell</a>)</p>
<div class="highlight"><pre><span></span>for x in (seq 1 50)
    setarch ppc64le -R taskset -c 24 erasure_code/gf_vect_mul_perf
end | awk &#39;/MB/ {sum+=$13} END {print sum/50, &quot;MB/s&quot;}&#39;
</pre></div>


</li>
<li>
<p>Debugging is tricky; the more you can do in C and the less you do in assembly, the easier your life will be.</p>
</li>
<li>
<p>Vector code is notoriously alignment-sensitive - if you can't figure out why something is wrong, check alignment. (Pro-tip: ISA-L does <em>not</em> guarantee the alignment of the <code>gftbls</code> parameter, and many of the tests supply an unaligned table from the stack. For testing <code>__attribute__((aligned(16)))</code> is your friend!)</p>
</li>
<li>
<p>Related: GCC is moving towards assignment over vector intrinsics, at least on Power:</p>
<div class="highlight"><pre><span></span>vector unsigned char a;
unsigned char * data;
// good, also handles word-aligned data with VSX
a = *(vector unsigned char *)data;
// bad, requires special handling of non-16-byte aligned data
a = vec_ld(0, (unsigned char *) data);
</pre></div>


</li>
</ul>
<h2>Conclusion</h2>
<p>Hopefully by this point you're equipped to figure out how your erasure coding library of choice works, and write your own optimised implementation (or maintain an implementation written by someone else).</p>
<p>I've referred to a number of resources throughout this series:</p>
<ul>
<li>ISA-L <a href="https://github.com/01org/isa-l">code</a>, <a href="">API description</a></li>
<li>Jerasure <a href="http://jerasure.org/">code</a>, <a href="http://jerasure.org/jerasure-2.0/">docs</a></li>
<li>gf-complete <a href="http://jerasure.org/">code</a>, <a href="http://jerasure.org/gf-complete-1.02/">docs</a> </li>
<li><a href="https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf">The mathematics of RAID-6</a> (PDF), H. Peter Anvin</li>
</ul>
<p>If you want to go deeper, I also read the following and found them quite helpful in understanding Galois Fields and Reed-Solomon coding:</p>
<ul>
<li><a href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19900019023.pdf">Tutorial on Reed-Solomon Error Correction Coding</a> (PDF), William A. Geisel, NASA</li>
<li><a href="https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19900019023.pdf">Reed-Solomon error correction</a> (PDF), BBC R&amp;D White Paper WHP 031, C. K. P. Clarke.</li>
</ul>
<p>For a more rigorous mathematical approach to rings and fields, a university mathematics course may be of interest. For more on coding theory, a university course in electronics engineering may be helpful.</p> </div><!-- /.entry-content -->
        </article></li>
</ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 2
        <a href="https://sthbrx.github.io/category/development2.html">&raquo;</a>
</p>
</section><!-- /#content -->
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>